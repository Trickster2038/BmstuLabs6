
nuancesprog.ru
6 упущений в курсе науки о данных
13-19 minutes

6 упущений в курсе науки о данных

Наука о данных  —  обширная тема. Для ее понимания требуется много времени, не говоря уже о полном овладении. Неудивительно, что многие учебные заведения, в отличие от традиционных курсов, разрабатывают специализированные программы по науке о данных. Эти программы, как правило, находятся на стыке информатики, математики и статистики. Студентов учат понимать и решать задачи с использованием данных и статистики. Однако программированию и практическому использованию решений уделяется недостаточно внимания.

Другими словами, углубленное изучение математики и статистики происходит в ущерб таким дисциплинам, как создание программного обеспечения, передовые методы программирования, разработка пользовательского интерфейса и базы данных. Кроме того, повышенное внимание к нейронным сетям отвлекает новичков от более простых и порой более эффективных технологий, таких как деревья решений и бустеры.

В этой статье освещаются аспекты, которые часто упускаются из виду в стандартных образовательных программах и которые, при должном внимании к ним, позволяют приобрести важнейшие компетенции в науке о данных. Конечно, не обязательно становится исключительным знатоком во всех областях Data Science. Тем не менее приобретение определенных навыков существенно повысит ваш профессиональный уровень в целом.
#1. Архитектура программного обеспечения

Инженеры ненавидят ноутбуки Jupyter по веской причине: они являются полной противоположностью “модульному подходу”.

Хороший дизайн программного обеспечения базируется на трех основополагающих принципах: высокая согласованность, низкая связанность и низкая избыточность. Другими словами, каждый из модулей специализируется на одной проблеме, они независимы друг от друга и в них практически нет дублирования кода. Так, код, загружающий набор данных, не должен выполнять ничего другого (например, очистку данных) или зависеть от какого-либо другого модуля (например, модуля расширения данных). Он должен быть единственным местом в кодовой базе, предназначенным для загрузки данных.

В большинстве учебников по науке о данных все помещается в один ноутбук, что с инженерной точки зрения совершенно недопустимо. Файл “все в одном” означает, что загрузка, очистка и подготовка набора данных происходит вместе с кодом, который его обслуживает и использует. Результирующий файл имеет множество пересекающихся задач, и, скорее всего, несколько ячеек, пришедших из других ноутбуков.

Архитектура программного обеспечения  —  это общая картина того, как каждый компонент соотносится с проектом и как в нем устроен код. Нет лучшего способа сделать эту картину максимально ясной, чем ежедневное критическое обдумывание каждого участка кода. Облегчить эту задачу может использование нескольких пакетов в Python, смешивание и сочетание PyTorch с NumPy, Pandas, SkLearn и т. д. Каждый модуль решает свою часть проблем, а все вместе они работают на проект в целом.

Теперь вспомните функции, которые вы недавно написали. Это были впервые созданные функции или повторяющиеся, которые вы в большей или меньшей степени переписываете в каждом проекте? Вы ведь не пишете заново код для повторяющихся функций? Зачастую написанный код оказывается неиспользуемым из-за того, что разработан под конкретную проблему или слишком связан с полным решением.

Как правило, чем более сфокусированным, независимым и уникальным является каждый модуль, тем лучше архитектура. Возможно, большая часть из написанного вами кода представляет собой “спагетти”, то есть запутана до такой степени, что вы не хотите утруждать себя исправлениями. Однако это не означает, что будущий код должен быть таким же. Все начинается с правильного мышления: написания независимых и многократно используемых частей.
#2. Разработка пользовательского интерфейса

Разработка интерфейсов  —  это совершенно другая сфера. Многие проблемы, с которыми сталкивается разработчик React или Vue, чужды специалистам по обработке данных. Между тем, изучение процесса разработки пользовательского интерфейса значительно улучшает навыки программирования. Главная проблема заключается в том, чтобы иметь возможность программировать инструменты, поскольку именно они определяют производительность.

Реальность такова, что большинство инструментов не лишены недостатков. Используемое вами приложение для маркировки данных было разработано для маркировки чего угодно, но только не того, что вам надо промаркировать. Применяемая вами библиотека построения графиков создавалась для поддержки большинства графиков, а не для ваших конкретных проектов. То же самое относится к IDE и языкам программирования. Они разработаны для общих, а не для ваших конкретных целей. Поэтому нетрудно понять, почему мы используем так много расширений кода VS или применяем TensorFlow, а не чистые Numpy и C.

Уметь программировать пользовательский интерфейс  —  не значит пытаться создать следующую версию Excel или Tableau. Программирование собственных инструментов  —  это действительно хорошее решение очень конкретной задачи. Такой задачи, которую ни один основной инструмент никогда не смог бы реализовать. Например, пользовательский интерфейс для исследования данных или пользовательская маркировка данных. Кроме того, вы можете использовать свои модели в качестве предварительных маркировщиков без особых усилий.

Вот вам задание в тему: подумайте, как интерфейс “что видишь  —  то и получаешь” способен помочь в том, чем вы сейчас занимаетесь. Насколько сложным он будет? Во что вам обойдется процесс написания кода? Сколько часов работы можно сэкономить?

Сегодня для разработки пользовательского интерфейса актуально изучение веб-фреймворков, таких как ReactJS или Vue. Если вы занимаетесь мобильными устройствами, рекомендую Flutter.
#3. Программная инженерия

Ни один из известных мне курсов по науке о данных не охватывает фундаментальных тем программной инженерии. Нас учат тому, как решать задачи обучения и вывода, но не тому, как правильно их программировать. Отсутствие навыков программной инженерии является основной причиной того, что команды разработчиков данных часто делятся на исследователей и инженеров. Первые поставляют модели, инсайты, анализы и т. д., а вторые собирают эти части для производства.

В самом начале я упомянул об архитектуре программного обеспечения, которая в общих чертах помогает понять, как сложное программное обеспечение разбивается на более мелкие, более управляемые части. Однако программная инженерия  —  это гораздо более широкая область, и архитектура программного обеспечения является одним из ее разделов. Неформально этот термин часто используется для обозначения двух важных подтем: как лучше писать программы и как лучше организовывать команды разработчиков.

Мое любимое определение инженерии  —  “оптимизация, улучшение”. Программная инженерия  —  не что иное, как все, что позволяет эффективнее создавать программное обеспечение. Речь идет о том, чтобы сделать его быстрее, более удобным для обслуживания, более безопасным, с меньшим числом ошибок и т. д., а также быстрее его написать, разделить работу между людьми, структурировать команды и т .д. Имеются в виду как продукт, так и процесс. Лучшее программное обеспечение и лучший способ создания программного обеспечения.

Зачем же изучать все это, если есть целая команда инженеров? Ответ простой: почти все, что мы делаем, является программным обеспечением или выполняется с помощью программного обеспечения. Ни одна команда никогда не жаловалась на то, что ее код слишком хорош. Ни одна команда никогда не жаловалась на то, что она программирует слишком быстро или код слишком удобен в плане поддержки. Жалуются всегда на то, как ужасно что-то написано или как медленно они продвигаются вперед. А не наоборот.

С чего начать?

Следуйте руководству по стилю вашего языка (PEP-8 для Python) и, помимо общих шаблонов, изучите шаблоны проектирования больших данных. Узнайте, как проводить модульное тестирование кода и как эффективно его распараллелить. Вы (надеюсь) знакомы с Git, но задумывались ли вы когда-нибудь об использовании трекера экспериментов или автоматизированной системы настройки? Ваша команда, скорее всего, следует какой-либо форме стратегии Scrum или Kanban, но читали ли вы когда-нибудь оригинальный Agile Manifesto?

Это  —  ориентиры. Каждый из них сам по себе является целой вселенной, которая заслуживает отдельной статьи. Однако, если бы мне пришлось выбрать что-то одно, я бы отдал предпочтение Agile Manifesto. Рекомендую ознакомиться со всеми 4 ценностями и 12 принципами. Быть гибким  —  не значит быть быстрым. Это значит быть адаптивным. Способность адаптироваться к изменениям  — противоположность негибкости, жесткости. Это относится ко всему в жизни. Приспосабливайтесь к вещам. Меняйте то, что требует изменений. Это касается и моделей обучения, и всей вашей карьеры, и кофе, который вы пьете.
#4. Как работают базы данных

Одно дело  —  знать SQL (язык структурированных запросов) и уметь запрашивать данные. Другое  —  понимать индексы и то, как данные хранятся и предоставляются системой базы данных. Большую роль в обучении (массивных) моделей на (монументальных) наборах данных играет входной конвейер. Если для получения пакета данных требуется больше времени, чем для его обработки, вы не сможете использовать GPU-компьютер в полной мере. Теоретические знания о базах данных позволят вам обрабатывать и обслуживать данные с масштабированием.

Речь не о том, что специалисты по анализу данных должны выполнять всю работу с базами данных или заменять администраторов баз данных. Напротив, ваша задача  —  изучение фундаментальных методов обслуживания данных. Вы должны знать в общих чертах, как хэшировать, сортировать, кэшировать и размещать данные  —  четыре основных пути оптимизации программного обеспечения. Кроме того, вам нужно понимать, насколько переупорядочивание операций может повлиять на время работы.

В документации по TensorFlow есть две замечательные статьи по оптимизации и анализу входных конвейеров. В них показано, как выполнение таких операций, как предварительная выборка данных, их параллельная обработка или векторизация, может значительно повысить производительность. Иногда это просто вопрос изменения порядка операций. Вы узнаете, как базы данных переписывают запросы для более быстрого выполнения. Большая часть материалов обеих статьей в равной степени применима и к другим процессам, например, к обработке фреймов данных Pandas.

Основной принцип перезаписывания запросов заключается в том, чтобы сначала отфильтровать данные. Допустим, вам нужно обработать набор данных изображений объемом 1 ТБ для обучения нейронной сети. В наборе данных 100 классов, но вам нужно научиться различать только 10. Вы можете либо (1) загрузить каждое изображение вслепую, а затем проверить их метки, либо (2) отфильтровать файлы нужных вам классов и пропустить остальные. Очевидно, что верный ответ  —  (2), поскольку он позволяет обойтись без загрузки данных, которые вы не будете использовать. Согласно установленным правилам баз данных, запросы “where” (“где”) выполняются первыми.
#5. Основы дизайна

Мы делаем уродливые графы. Многим не помешало бы проштудировать статьи из серии “дизайн для чайников”. Несколько базовых правил научат вас раскрашивать диаграммы и определять размер текста в них. Дополнительные знания помогут более творчески подходить к отображению данных. Хорошая визуализация стоит миллиона изображений.

Лучшим стартом будет использование некоторых заготовок, таких как Seaborn, палитры MatplotLib или темы Plotly. Затем следует научиться лучше понимать значения цветов и находить удачные цветовые сочетания. Однако самое важное, чем вам нужно овладеть,  —  это составление визуальной иерархии. Хороший сюжет направляет взгляд читателя на то, что ему необходимо узнать/осознать в первую очередь. Если этого не сделать, изображение будет сбивать с толку и отпугивать.

Тем не менее, как бы вы ни создавали свои визуализации, всегда стремитесь к тому, чтобы сюжеты были самоочевидными. Никогда не полагайтесь на текст, который не находится в самом графе, чтобы пояснить, что показывает граф.
#6. Машинное обучение помимо нейронных сетей

Существует целый мир алгоритмов машинного обучения, о котором многие специалисты по обработке данных даже не подозревают. Несмотря на популярность линейной/логистической регрессии и нейронных сетей, многие проблемы можно решить гораздо быстрее с помощью простых SVM с ядром RBF или модели XGBoost. Традиционные деревья решений часто достаточно эффективны для табличных данных и имеют дополнительное преимущество  —  они полностью объяснимы. Не стоит игнорировать прошлые подходы. В них много ценных примеров решения сложных задач.

Хотя большинство из вас знакомы с этими алгоритмами, растущее доминирование нейронных сетей неуклонно сокращает внимание, уделяемое классическим методам. В результате сегодня многие профессионалы гораздо лучше знакомы с Transformers и ResNets, чем со старым добрым Scikit-Learn.

Я выделяю три модели, которые должны знать и уметь использовать все специалисты по данным:

    Деревья решений  —  один из самых простых и мощных классификаторов. Их сила в невероятной объяснимости. Вы можете легко напечатать, как мыслит дерево решений. Это то, что не под силу большинству моделей. Ограничение деревьев решений заключается в том, что они не очень подходят для решения сложных проблем. Подробнее читайте здесь.
    Бустеры. Самый известный  —  XGBoost. Это деревья решений “на стероидах”. Они также хорошо объяснимы, но, вместо впечатляющей простоты, предлагают отличную классификацию. При работе с массивными табличными наборами данных бустеры являются одними из самых эффективных методов. Альтернативы XGBoost  —  LightGBM и CatBoost.
    Машины опорных векторов (Support Vector Machines, SVM). Основанные на строгом математическом описании, SVM принадлежат к числу самых успешных моделей, когда-либо разработанных. Они блестяще справляются со сложными задачами с небольшими наборами данных, но с множеством характеристик. SVM преуспевают в таких жестких условиях, в которых другие модели не способны обучаться. Вот документация SkLearn по SVM.

В завершение не могу не упомянуть о Naive-Bayes. Эта относительно быстрая и простая модель заслуживает вашего внимания. Она достаточно успешно решает задачи с большим количеством характеристик. К тому же, Naive-Bayes довольно популярна в сообществе обработки естественного языка (NLP) благодаря тому, что достаточно эффективно учитывает каждое слово в документе.

На этом пока все. Спасибо, что дочитали до конца.

Читайте также:

    Наука о данных простым языком
    Инструменты для быстрого овладения наукой о данных
    Годовой план изучения науки о данных

Читайте нас в Telegram, VK и Яндекс.Дзен

Перевод статьи Ygor Serpa: 6 Things You Did Not Learn In Your Data Science Course
